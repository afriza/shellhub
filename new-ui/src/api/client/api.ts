/* tslint:disable */
/* eslint-disable */
/**
 * ShellHub Enterprise
 * ShellHub Enterprise.  It documents all routes provided by ShellHub Enterprise.   NOTICE: THE API IS NOT STABLE YET; ERROR AND INCONSISTENCIES MAY OCCUR. 
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: contato@ossystems.com.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddNamespaceMemberRequest
 */
export interface AddNamespaceMemberRequest {
    /**
     * Member\'s username.
     * @type {string}
     * @memberof AddNamespaceMemberRequest
     */
    'username': string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof AddNamespaceMemberRequest
     */
    'role': NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface AddTagPublicKeyRequest
 */
export interface AddTagPublicKeyRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof AddTagPublicKeyRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface CreateDeviceTagRequest
 */
export interface CreateDeviceTagRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof CreateDeviceTagRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface CreateNamespaceAdminRequest
 */
export interface CreateNamespaceAdminRequest {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof CreateNamespaceAdminRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Device
     */
    'uid'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof Device
     */
    'name'?: string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof Device
     */
    'identity'?: DeviceIdentity;
    /**
     * 
     * @type {DeviceInfo}
     * @memberof Device
     */
    'info'?: DeviceInfo;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof Device
     */
    'public_key'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Device
     */
    'tenant_id'?: string;
    /**
     * Device\'s last seen date
     * @type {string}
     * @memberof Device
     */
    'last_seen'?: string;
    /**
     * Device\'s availability status
     * @type {boolean}
     * @memberof Device
     */
    'online'?: boolean;
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Device
     */
    'namespace'?: string;
    /**
     * 
     * @type {DeviceStatus}
     * @memberof Device
     */
    'status'?: DeviceStatus;
    /**
     * Device\'s creation date
     * @type {string}
     * @memberof Device
     */
    'created_at'?: string;
    /**
     * Device\'s remote address
     * @type {string}
     * @memberof Device
     */
    'remote_addr'?: string;
    /**
     * 
     * @type {DevicePosition}
     * @memberof Device
     */
    'position'?: DevicePosition;
    /**
     * Device\'s Tags list
     * @type {Array<string>}
     * @memberof Device
     */
    'tags'?: Array<string>;
}
/**
 * Device\'s identity
 * @export
 * @interface DeviceIdentity
 */
export interface DeviceIdentity {
    /**
     * Device\'s MAC
     * @type {string}
     * @memberof DeviceIdentity
     */
    'mac'?: string;
}
/**
 * Device\'s info
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * Device\'s OS name
     * @type {string}
     * @memberof DeviceInfo
     */
    'id'?: string;
    /**
     * Device\'s OS pretty name
     * @type {string}
     * @memberof DeviceInfo
     */
    'pretty_name'?: string;
    /**
     * Device\'s OS version
     * @type {string}
     * @memberof DeviceInfo
     */
    'version'?: string;
    /**
     * Device\'s OS arch
     * @type {string}
     * @memberof DeviceInfo
     */
    'arch'?: string;
    /**
     * Device\'s OS platform
     * @type {string}
     * @memberof DeviceInfo
     */
    'platform'?: DeviceInfoPlatformEnum;
}

export const DeviceInfoPlatformEnum = {
    Docker: 'docker',
    Native: 'native'
} as const;

export type DeviceInfoPlatformEnum = typeof DeviceInfoPlatformEnum[keyof typeof DeviceInfoPlatformEnum];

/**
 * Device\'s geolocation position
 * @export
 * @interface DevicePosition
 */
export interface DevicePosition {
    /**
     * Device\'s latitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'latitude'?: number;
    /**
     * Device\'s longitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'longitude'?: number;
}
/**
 * Device\'s status
 * @export
 * @enum {string}
 */

export const DeviceStatus = {
    Accepted: 'accepted',
    Rejected: 'rejected',
    Pending: 'pending',
    Unused: 'unused'
} as const;

export type DeviceStatus = typeof DeviceStatus[keyof typeof DeviceStatus];


/**
 * 
 * @export
 * @interface EnableRecordSession422Response
 */
export interface EnableRecordSession422Response {
    /**
     * 
     * @type {string}
     * @memberof EnableRecordSession422Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface EnableRecordSession500Response
 */
export interface EnableRecordSession500Response {
    /**
     * Error message
     * @type {string}
     * @memberof EnableRecordSession500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FirewallRulesRequest
 */
export interface FirewallRulesRequest {
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'action': FirewallRulesRequestActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesRequest
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesRequest
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesRequest
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'username': string;
}

export const FirewallRulesRequestActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesRequestActionEnum = typeof FirewallRulesRequestActionEnum[keyof typeof FirewallRulesRequestActionEnum];

/**
 * 
 * @export
 * @interface FirewallRulesResponse
 */
export interface FirewallRulesResponse {
    /**
     * Firewall rule\'s ID.
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'tenant_id': string;
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'action': FirewallRulesResponseActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesResponse
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesResponse
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesResponse
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'username': string;
}

export const FirewallRulesResponseActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesResponseActionEnum = typeof FirewallRulesResponseActionEnum[keyof typeof FirewallRulesResponseActionEnum];

/**
 * @type FirewallRulesResponseFilter
 * Firewall rule\'s filter
 * @export
 */
export type FirewallRulesResponseFilter = FirewallRulesResponseFilterOneOf | FirewallRulesResponseFilterOneOf1;

/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf
 */
export interface FirewallRulesResponseFilterOneOf {
    /**
     * Firewall rule\'s hostname
     * @type {string}
     * @memberof FirewallRulesResponseFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf1
 */
export interface FirewallRulesResponseFilterOneOf1 {
    /**
     * Firewall\'s rule tags
     * @type {Array<string>}
     * @memberof FirewallRulesResponseFilterOneOf1
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GetLicense200Response
 */
export interface GetLicense200Response {
    /**
     * License\'s ID
     * @type {string}
     * @memberof GetLicense200Response
     */
    'id': string;
    /**
     * License\'s expired status
     * @type {boolean}
     * @memberof GetLicense200Response
     */
    'expired': boolean;
    /**
     * License\'s about to expire status
     * @type {boolean}
     * @memberof GetLicense200Response
     */
    'about_to_expire': boolean;
    /**
     * License\'s grace period status
     * @type {boolean}
     * @memberof GetLicense200Response
     */
    'grace_period': boolean;
    /**
     * License\'s issued at  It is the number of seconds elapsed since January 1, 1970 UTC.
     * @type {number}
     * @memberof GetLicense200Response
     */
    'issued_at': number;
    /**
     * License\'s started at  It is the number of seconds elapsed since January 1, 1970 UTC.
     * @type {number}
     * @memberof GetLicense200Response
     */
    'starts_at': number;
    /**
     * License\'s expired at  It is the number of seconds elapsed since January 1, 1970 UTC.  `-1` means license does not expire
     * @type {number}
     * @memberof GetLicense200Response
     */
    'expires_at': number;
    /**
     * License\'s allowed regions  It is a list of regions in `ISO 3166-1 alpha-2` format.
     * @type {Array<string>}
     * @memberof GetLicense200Response
     */
    'allowed_regions': Array<GetLicense200ResponseAllowedRegionsEnum>;
    /**
     * 
     * @type {GetLicense200ResponseCustomer}
     * @memberof GetLicense200Response
     */
    'customer': GetLicense200ResponseCustomer;
    /**
     * 
     * @type {GetLicense200ResponseFeatures}
     * @memberof GetLicense200Response
     */
    'features': GetLicense200ResponseFeatures;
}

export const GetLicense200ResponseAllowedRegionsEnum = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    Ao: 'AO',
    Aq: 'AQ',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Ax: 'AX',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bl: 'BL',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Bq: 'BQ',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bv: 'BV',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cc: 'CC',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cw: 'CW',
    Cx: 'CX',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Eh: 'EH',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gs: 'GS',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hm: 'HM',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    Im: 'IM',
    In: 'IN',
    Io: 'IO',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mf: 'MF',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Nf: 'NF',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pm: 'PM',
    Pn: 'PN',
    Pr: 'PR',
    Ps: 'PS',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sj: 'SJ',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sx: 'SX',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tf: 'TF',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tk: 'TK',
    Tm: 'TM',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Um: 'UM',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Wf: 'WF',
    Ws: 'WS',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type GetLicense200ResponseAllowedRegionsEnum = typeof GetLicense200ResponseAllowedRegionsEnum[keyof typeof GetLicense200ResponseAllowedRegionsEnum];

/**
 * License\'s customer
 * @export
 * @interface GetLicense200ResponseCustomer
 */
export interface GetLicense200ResponseCustomer {
    /**
     * Customer\'s ID
     * @type {string}
     * @memberof GetLicense200ResponseCustomer
     */
    'id'?: string;
    /**
     * Customer\'s name
     * @type {string}
     * @memberof GetLicense200ResponseCustomer
     */
    'name'?: string;
    /**
     * Customer\'s email
     * @type {string}
     * @memberof GetLicense200ResponseCustomer
     */
    'email'?: string;
    /**
     * Customer\'s company
     * @type {string}
     * @memberof GetLicense200ResponseCustomer
     */
    'company'?: string;
}
/**
 * License\'s features
 * @export
 * @interface GetLicense200ResponseFeatures
 */
export interface GetLicense200ResponseFeatures {
    /**
     * Number of devices allowed   `-1` means unlimited number of devices and any other number means the number of devices allowed 
     * @type {number}
     * @memberof GetLicense200ResponseFeatures
     */
    'devices': number;
    /**
     * Session recording status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'session_recording': boolean;
    /**
     * Firewall rules status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'firewall_rules': boolean;
    /**
     * Reports status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'reports': boolean;
    /**
     * Login link status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'login_link': boolean;
    /**
     * Billing status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'billing': boolean;
}
/**
 * 
 * @export
 * @interface GetStats200Response
 */
export interface GetStats200Response {
    /**
     * Number of registered users.
     * @type {number}
     * @memberof GetStats200Response
     */
    'registered_users'?: number;
    /**
     * Number of registered devices.
     * @type {number}
     * @memberof GetStats200Response
     */
    'registered_devices'?: number;
    /**
     * Number of online devices.
     * @type {number}
     * @memberof GetStats200Response
     */
    'online_devices'?: number;
    /**
     * Number of active sessions.
     * @type {number}
     * @memberof GetStats200Response
     */
    'active_sessions'?: number;
    /**
     * Number of pending devices.
     * @type {number}
     * @memberof GetStats200Response
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices.
     * @type {number}
     * @memberof GetStats200Response
     */
    'rejected_devices'?: number;
}
/**
 * 
 * @export
 * @interface GetStatusDevices200Response
 */
export interface GetStatusDevices200Response {
    /**
     * Number of registered devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'registered_devices'?: number;
    /**
     * Number of online devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'online_devices'?: number;
    /**
     * Number of pending devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'rejected_devices'?: number;
    /**
     * Active sessions
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'active_sessions'?: number;
}
/**
 * 
 * @export
 * @interface GetUser200Response
 */
export interface GetUser200Response {
    /**
     * 
     * @type {UserAdminResponse}
     * @memberof GetUser200Response
     */
    'user'?: UserAdminResponse;
    /**
     * User\'s integer of owned namespaces
     * @type {number}
     * @memberof GetUser200Response
     */
    'namespacesOwned'?: number;
}
/**
 * 
 * @export
 * @interface GetUserTokenAdmin200Response
 */
export interface GetUserTokenAdmin200Response {
    /**
     * JWT Token
     * @type {string}
     * @memberof GetUserTokenAdmin200Response
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * ShellHub instance version.
     * @type {string}
     * @memberof Info
     */
    'version'?: string;
    /**
     * 
     * @type {InfoEndpoints}
     * @memberof Info
     */
    'endpoints'?: InfoEndpoints;
}
/**
 * 
 * @export
 * @interface InfoEndpoints
 */
export interface InfoEndpoints {
    /**
     * SSH endpoint.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'ssh'?: string;
    /**
     * API endpoint.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'api'?: string;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * Username
     * @type {string}
     * @memberof Login
     */
    'username': string;
    /**
     * Password
     * @type {string}
     * @memberof Login
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginAdmin200Response
 */
export interface LoginAdmin200Response {
    /**
     * JWT token
     * @type {string}
     * @memberof LoginAdmin200Response
     */
    'token'?: string;
    /**
     * username
     * @type {string}
     * @memberof LoginAdmin200Response
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface LoginAdminRequest
 */
export interface LoginAdminRequest {
    /**
     * Admin\'s username
     * @type {string}
     * @memberof LoginAdminRequest
     */
    'username': string;
    /**
     * Admin\'s password
     * @type {string}
     * @memberof LoginAdminRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Namespace
 */
export interface Namespace {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Namespace
     */
    'name'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof Namespace
     */
    'owner'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Namespace
     */
    'tenant_id'?: string;
    /**
     * Namespace\'s members
     * @type {Array<NamespaceMembersInner>}
     * @memberof Namespace
     */
    'members'?: Array<NamespaceMembersInner>;
    /**
     * 
     * @type {NamespaceSettings}
     * @memberof Namespace
     */
    'settings'?: NamespaceSettings;
    /**
     * Namespace\'s max device numbers
     * @type {number}
     * @memberof Namespace
     */
    'max_devices'?: number;
    /**
     * Namespace\'s total devices
     * @type {number}
     * @memberof Namespace
     */
    'device_count'?: number;
    /**
     * Namespace\'s creation date
     * @type {string}
     * @memberof Namespace
     */
    'created_at'?: string;
    /**
     * Namespace\'s billing
     * @type {object}
     * @memberof Namespace
     */
    'billing'?: object;
}
/**
 * Namespace\'s member role
 * @export
 * @enum {string}
 */

export const NamespaceMemberRole = {
    Administrator: 'administrator',
    Operator: 'operator',
    Observer: 'observer',
    Owner: 'owner'
} as const;

export type NamespaceMemberRole = typeof NamespaceMemberRole[keyof typeof NamespaceMemberRole];


/**
 * 
 * @export
 * @interface NamespaceMembersInner
 */
export interface NamespaceMembersInner {
    /**
     * User\'s ID.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'id'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof NamespaceMembersInner
     */
    'role'?: NamespaceMemberRole;
}
/**
 * Namespace\'s settings
 * @export
 * @interface NamespaceSettings
 */
export interface NamespaceSettings {
    /**
     * Namespace\'s session record status
     * @type {boolean}
     * @memberof NamespaceSettings
     */
    'session_record'?: boolean;
}
/**
 * 
 * @export
 * @interface PostAuthDevice200Response
 */
export interface PostAuthDevice200Response {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof PostAuthDevice200Response
     */
    'uid'?: string;
    /**
     * Device\'s token
     * @type {string}
     * @memberof PostAuthDevice200Response
     */
    'token'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof PostAuthDevice200Response
     */
    'name'?: string;
    /**
     * Device\'s namespace name
     * @type {string}
     * @memberof PostAuthDevice200Response
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface PostAuthDeviceRequest
 */
export interface PostAuthDeviceRequest {
    /**
     * 
     * @type {DeviceInfo}
     * @memberof PostAuthDeviceRequest
     */
    'info': DeviceInfo;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostAuthDeviceRequest
     */
    'sessions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostAuthDeviceRequest
     */
    'hostname': string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof PostAuthDeviceRequest
     */
    'identity'?: DeviceIdentity;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof PostAuthDeviceRequest
     */
    'public_key': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof PostAuthDeviceRequest
     */
    'tenant_id': string;
}
/**
 * @type PublicKeyFilter
 * Public key\'s filter rule.   The `filter`` rule defines how if the public key is valid to a device.  - When `hostname` object is set, the public key will be used in a device what matches with hostname. - When `tags` object is set, it matches the device what contains at least one of that tags.  
 * @export
 */
export type PublicKeyFilter = PublicKeyFilterOneOf | PublicKeyFilterOneOf1;

/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf
 */
export interface PublicKeyFilterOneOf {
    /**
     * Public key\'s regex hostname.
     * @type {string}
     * @memberof PublicKeyFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf1
 */
export interface PublicKeyFilterOneOf1 {
    /**
     * Public key\'s tags.
     * @type {Set<string>}
     * @memberof PublicKeyFilterOneOf1
     */
    'tags': Set<string>;
}
/**
 * 
 * @export
 * @interface PublicKeyRequest
 */
export interface PublicKeyRequest {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'data': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyRequest
     */
    'filter': PublicKeyFilter;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PublicKeyResponse
 */
export interface PublicKeyResponse {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'fingerprint'?: string;
    /**
     * Public key\'s creation date.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'created_at'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyResponse
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface RecordedSessionResponseInner
 */
export interface RecordedSessionResponseInner {
    /**
     * Session\'s ID
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'uid': string;
    /**
     * Session\'s Data
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'message': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'tenant_id': string;
    /**
     * Session\'s time
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'time': string;
    /**
     * Session\'s terminal width
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'width': number;
    /**
     * Session\'s terminal height
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface RenameTagRequest
 */
export interface RenameTagRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof RenameTagRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * Session\'s UID
     * @type {string}
     * @memberof Session
     */
    'uid'?: string;
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Session
     */
    'device_uid'?: string;
    /**
     * 
     * @type {Device}
     * @memberof Session
     */
    'device'?: Device;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Session
     */
    'tenant_id'?: string;
    /**
     * Session\'s username
     * @type {string}
     * @memberof Session
     */
    'username'?: string;
    /**
     * Session\'s IP address
     * @type {string}
     * @memberof Session
     */
    'ip_address'?: string;
    /**
     * Session\'s started date
     * @type {string}
     * @memberof Session
     */
    'started_at'?: string;
    /**
     * Session\'s last seen date
     * @type {string}
     * @memberof Session
     */
    'last_seen'?: string;
    /**
     * Session\'s active status
     * @type {boolean}
     * @memberof Session
     */
    'active'?: boolean;
    /**
     * Session\'s authenticated status
     * @type {boolean}
     * @memberof Session
     */
    'authenticated'?: boolean;
    /**
     * Session\'s recorded status
     * @type {boolean}
     * @memberof Session
     */
    'recorded'?: boolean;
    /**
     * Session\'s type
     * @type {string}
     * @memberof Session
     */
    'type'?: SessionTypeEnum;
    /**
     * Session\'s terminal
     * @type {string}
     * @memberof Session
     */
    'term'?: string;
}

export const SessionTypeEnum = {
    Web: 'web',
    Term: 'term'
} as const;

export type SessionTypeEnum = typeof SessionTypeEnum[keyof typeof SessionTypeEnum];

/**
 * 
 * @export
 * @interface SetSSHKey200Response
 */
export interface SetSSHKey200Response {
    /**
     * Device signature
     * @type {string}
     * @memberof SetSSHKey200Response
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface SetSSHKeyRequest
 */
export interface SetSSHKeyRequest {
    /**
     * Device fingerprint
     * @type {string}
     * @memberof SetSSHKeyRequest
     */
    'fingerprint'?: string;
    /**
     * Device SSH public key
     * @type {string}
     * @memberof SetSSHKeyRequest
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface SetSessionAuthenticationStatusAdminRequest
 */
export interface SetSessionAuthenticationStatusAdminRequest {
    /**
     * Session\'s authentication status.
     * @type {boolean}
     * @memberof SetSessionAuthenticationStatusAdminRequest
     */
    'authenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface SetSessionRecordRequest
 */
export interface SetSessionRecordRequest {
    /**
     * Session\'s record status.
     * @type {boolean}
     * @memberof SetSessionRecordRequest
     */
    'session_record'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateDeviceNameAdminRequest
 */
export interface UpdateDeviceNameAdminRequest {
    /**
     * Device\'s new name.
     * @type {string}
     * @memberof UpdateDeviceNameAdminRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateNamespaceMemberRequest
 */
export interface UpdateNamespaceMemberRequest {
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UpdateNamespaceMemberRequest
     */
    'role'?: NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface UpdatePublicKeyRequest
 */
export interface UpdatePublicKeyRequest {
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s username.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'username': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof UpdatePublicKeyRequest
     */
    'filter': PublicKeyFilter;
}
/**
 * 
 * @export
 * @interface UpdateTagsDeviceRequest
 */
export interface UpdateTagsDeviceRequest {
    /**
     * Device\'s Tags list
     * @type {Array<string>}
     * @memberof UpdateTagsDeviceRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateTagsPublicKeyRequest
 */
export interface UpdateTagsPublicKeyRequest {
    /**
     * Public key\'s new tags.
     * @type {Set<string>}
     * @memberof UpdateTagsPublicKeyRequest
     */
    'tags'?: Set<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserDataRequest
 */
export interface UpdateUserDataRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'name': string;
    /**
     * User\'s e-mail.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'email': string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordRequest
 */
export interface UpdateUserPasswordRequest {
    /**
     * User current password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'current_password'?: string;
    /**
     * User new password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'new_password'?: string;
}
/**
 * 
 * @export
 * @interface UserAdminRequest
 */
export interface UserAdminRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAdminRequest
     */
    'name': string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAdminRequest
     */
    'email': string;
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAdminRequest
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof UserAdminRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserAdminResponse
 */
export interface UserAdminResponse {
    /**
     * User\'s ID.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'id'?: string;
    /**
     * User\'s integer of owned namespaces.
     * @type {number}
     * @memberof UserAdminResponse
     */
    'namespaces'?: number;
    /**
     * User\'s confirmation.
     * @type {boolean}
     * @memberof UserAdminResponse
     */
    'confirmed'?: boolean;
    /**
     * User\'s creating date.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'created_at'?: string;
    /**
     * User\'s last login date.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'last_login'?: string;
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'name'?: string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'email'?: string;
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'username'?: string;
    /**
     * User\'s hashed password.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UserAuth
 */
export interface UserAuth {
    /**
     * JWT Token
     * @type {string}
     * @memberof UserAuth
     */
    'token'?: string;
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAuth
     */
    'user'?: string;
    /**
     * User\'s display name.
     * @type {string}
     * @memberof UserAuth
     */
    'name'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof UserAuth
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof UserAuth
     */
    'tenant'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UserAuth
     */
    'role'?: NamespaceMemberRole;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAuth
     */
    'email'?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin: async (tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin: async (userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin: async (tenantID: string, namespace?: Namespace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantID' is not null or undefined
            assertParamExists('editNamespaceAdmin', 'tenantID', tenantID)
            const localVarPath = `/admin/api/namespaces-update/{tenantID}`
                .replace(`{${"tenantID"}}`, encodeURIComponent(String(tenantID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export namespaces to csv file.
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTokenAdmin', 'id', id)
            const localVarPath = `/admin/api/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin: async (loginAdminRequest?: LoginAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin: async (uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatusAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceNameAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin: async (uid: string, status: DeviceStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'status', status)
            const localVarPath = `/admin/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleAdmin(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdmin(userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleAdmin(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespaceAdmin(tenantID, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export namespaces to csv file.
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRuleAdmin(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRulesAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicense(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicense200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesAdmin(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTokenAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAdmin(loginAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLicense(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLicense(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusAdmin(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleAdmin(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin(userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUserAdmin(userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: any): AxiosPromise<void> {
            return localVarFp.editNamespaceAdmin(tenantID, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Export namespaces to csv file.
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<any> {
            return localVarFp.exportNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<any> {
            return localVarFp.exportUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRulesAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense(options?: any): AxiosPromise<GetLicense200Response> {
            return localVarFp.getLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespacesAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSessionAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessionsAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<GetStats200Response> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin(id: string, options?: any): AxiosPromise<GetUserTokenAdmin200Response> {
            return localVarFp.getUserTokenAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<UserAdminResponse>> {
            return localVarFp.getUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: any): AxiosPromise<LoginAdmin200Response> {
            return localVarFp.loginAdmin(loginAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.sendLicense(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusAdmin(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(id, userAdminRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Create a firewall rule.
     * @summary Create firewall rule Admin
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a User.
     * @summary Create a User admin
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createUserAdmin(userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule admin
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteFirewallRuleAdmin(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace admin
     * @param {string} tenantID Namespace\&#39;s tenant ID
     * @param {Namespace} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).editNamespaceAdmin(tenantID, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export namespaces to csv file.
     * @summary export namespace
     * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public exportNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).exportNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export users to csv file.
     * @summary export users
     * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public exportUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).exportUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices admin
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule admin
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getFirewallRuleAdmin(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules Admin
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getFirewallRulesAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the license data.
     * @summary Get license data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getLicense(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces admin
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getNamespacesAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session admin
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getSessionAdmin(uid: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getSessionAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions admin
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getSessionsAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats about the ShellHub instance.
     * @summary Get stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user.
     * @summary Get user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user JWT token to login.
     * @summary Get user token
     * @param {string} id User\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUserTokenAdmin(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUserTokenAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of users.
     * @summary Get users
     * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login on Admin
     * @summary Login on Admin
     * @param {LoginAdminRequest} [loginAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).loginAdmin(loginAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send license data
     * @summary Send license data
     * @param {any} [file] License\\\&#39;s file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public sendLicense(file?: any, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).sendLicense(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status admin
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name Admin
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update status Admin
     * @param {string} uid Device\&#39;s UID
     * @param {DeviceStatus} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateDeviceStatusAdmin(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule admin
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update user
     * @param {string} id 
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateUser(id, userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudApi - axios parameter creator
 * @export
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordSession: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteRecordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecordSession: async (uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('enableRecordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordedSessionResponseInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 * @export
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordSession(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordSession(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableRecordSession(uid, recordedSessionResponseInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudApi - factory interface
 * @export
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordSession(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRecordSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: any): AxiosPromise<void> {
            return localVarFp.enableRecordSession(uid, recordedSessionResponseInner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudApi - object-oriented interface
 * @export
 * @class CloudApi
 * @extends {BaseAPI}
 */
export class CloudApi extends BaseAPI {
    /**
     * Delete a session record
     * @summary Delete a session record
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public deleteRecordSession(uid: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteRecordSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a session record
     * @summary Enable a session record
     * @param {string} uid 
     * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).enableRecordSession(uid, recordedSessionResponseInner, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get info about ShellHub instance.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (agentVersion?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentVersion !== undefined) {
                localVarQueryParameter['agent_version'] = agentVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get info about ShellHub instance.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(agentVersion?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(agentVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Get info about ShellHub instance.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(agentVersion?: string, options?: any): AxiosPromise<Info> {
            return localVarFp.getInfo(agentVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get info about ShellHub instance.
     * @summary Get info
     * @param {string} [agentVersion] Agent\&#39;s version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInfo(agentVersion?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInfo(agentVersion, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createDeviceTag', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tag', tag)
            const localVarPath = `/api/devices/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthDevice: async (xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAuthDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthDevice_1: async (xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAuthDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceName: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceName', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceNameAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus: async (uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatus', 'status', status)
            const localVarPath = `/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin: async (uid: string, status: DeviceStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'status', status)
            const localVarPath = `/admin/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusDevices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthDevice(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthDevice(xRealIP, postAuthDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthDevice_1(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthDevice_1(xRealIP, postAuthDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s name.
         * @summary Update device name
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceName(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceName(uid, updateDeviceNameAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatus(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusAdmin(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsDevice(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices(options?: any): AxiosPromise<GetStatusDevices200Response> {
            return localVarFp.getStatusDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthDevice(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: any): AxiosPromise<PostAuthDevice200Response> {
            return localVarFp.postAuthDevice(xRealIP, postAuthDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthDevice_1(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: any): AxiosPromise<PostAuthDevice200Response> {
            return localVarFp.postAuthDevice_1(xRealIP, postAuthDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceName(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceName(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusAdmin(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from device.
     * @summary Delete a tag from device
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDeviceTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices admin
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats ShellHub instance.
     * @summary Get stats ShellHub instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getStatusDevices(options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getStatusDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public postAuthDevice(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).postAuthDevice(xRealIP, postAuthDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth a device.  Every 30 seconds, this route is hit by internal ShellHub to check device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {PostAuthDeviceRequest} [postAuthDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public postAuthDevice_1(xRealIP?: string, postAuthDeviceRequest?: PostAuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).postAuthDevice_1(xRealIP, postAuthDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceName(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceName(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name Admin
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update device status
     * @param {string} uid Device\&#39;s UID
     * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update status Admin
     * @param {string} uid Device\&#39;s UID
     * @param {DeviceStatus} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatusAdmin(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to device
     * @summary Update tags to device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExternalApi - axios parameter creator
 * @export
 */
export const ExternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin: async (tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin: async (userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin: async (tenantID: string, namespace?: Namespace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantID' is not null or undefined
            assertParamExists('editNamespaceAdmin', 'tenantID', tenantID)
            const localVarPath = `/admin/api/namespaces-update/{tenantID}`
                .replace(`{${"tenantID"}}`, encodeURIComponent(String(tenantID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin: async (loginAdminRequest?: LoginAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin: async (uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatusAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceNameAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin: async (uid: string, status: DeviceStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'status', status)
            const localVarPath = `/admin/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalApi - functional programming interface
 * @export
 */
export const ExternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleAdmin(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdmin(userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleAdmin(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespaceAdmin(tenantID, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRuleAdmin(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRulesAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicense(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicense200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesAdmin(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAdmin(loginAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLicense(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLicense(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusAdmin(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleAdmin(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExternalApi - factory interface
 * @export
 */
export const ExternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalApiFp(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin(userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUserAdmin(userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: any): AxiosPromise<void> {
            return localVarFp.editNamespaceAdmin(tenantID, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRulesAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense(options?: any): AxiosPromise<GetLicense200Response> {
            return localVarFp.getLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespacesAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSessionAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessionsAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<GetStats200Response> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<UserAdminResponse>> {
            return localVarFp.getUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: any): AxiosPromise<LoginAdmin200Response> {
            return localVarFp.loginAdmin(loginAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.sendLicense(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusAdmin(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(id, userAdminRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalApi - object-oriented interface
 * @export
 * @class ExternalApi
 * @extends {BaseAPI}
 */
export class ExternalApi extends BaseAPI {
    /**
     * Create a firewall rule.
     * @summary Create firewall rule Admin
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a User.
     * @summary Create a User admin
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).createUserAdmin(userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).deleteDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule admin
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public deleteFirewallRuleAdmin(id: number, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).deleteFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).deleteNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace admin
     * @param {string} tenantID Namespace\&#39;s tenant ID
     * @param {Namespace} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).editNamespaceAdmin(tenantID, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices admin
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule admin
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getFirewallRuleAdmin(id: number, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules Admin
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getFirewallRulesAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the license data.
     * @summary Get license data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getLicense(options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces admin
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getNamespacesAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session admin
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getSessionAdmin(uid: string, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getSessionAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions admin
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getSessionsAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats about the ShellHub instance.
     * @summary Get stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user.
     * @summary Get user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of users.
     * @summary Get users
     * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).getUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login on Admin
     * @summary Login on Admin
     * @param {LoginAdminRequest} [loginAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).loginAdmin(loginAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send license data
     * @summary Send license data
     * @param {any} [file] License\\\&#39;s file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public sendLicense(file?: any, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).sendLicense(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status admin
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name Admin
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update status Admin
     * @param {string} uid Device\&#39;s UID
     * @param {DeviceStatus} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).updateDeviceStatusAdmin(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule admin
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update user
     * @param {string} id 
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).updateUser(id, userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordSession: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteRecordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecordSession: async (uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('enableRecordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordedSessionResponseInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordSession(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordSession(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableRecordSession(uid, recordedSessionResponseInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordSession(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRecordSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: any): AxiosPromise<void> {
            return localVarFp.enableRecordSession(uid, recordedSessionResponseInner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Delete a session record
     * @summary Delete a session record
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteRecordSession(uid: string, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).deleteRecordSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a session record
     * @summary Enable a session record
     * @param {string} uid 
     * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).enableRecordSession(uid, recordedSessionResponseInner, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LicenseApi - axios parameter creator
 * @export
 */
export const LicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseApi - functional programming interface
 * @export
 */
export const LicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicense(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicense200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLicense(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLicense(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LicenseApi - factory interface
 * @export
 */
export const LicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseApiFp(configuration)
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense(options?: any): AxiosPromise<GetLicense200Response> {
            return localVarFp.getLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.sendLicense(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseApi - object-oriented interface
 * @export
 * @class LicenseApi
 * @extends {BaseAPI}
 */
export class LicenseApi extends BaseAPI {
    /**
     * Get the license data.
     * @summary Get license data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public getLicense(options?: AxiosRequestConfig) {
        return LicenseApiFp(this.configuration).getLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send license data
     * @summary Send license data
     * @param {any} [file] License\\\&#39;s file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public sendLicense(file?: any, options?: AxiosRequestConfig) {
        return LicenseApiFp(this.configuration).sendLicense(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NamespacesApi - axios parameter creator
 * @export
 */
export const NamespacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace: async (tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin: async (tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace: async (tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('editNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin: async (tenantID: string, namespace?: Namespace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantID' is not null or undefined
            assertParamExists('editNamespaceAdmin', 'tenantID', tenantID)
            const localVarPath = `/admin/api/namespaces-update/{tenantID}`
                .replace(`{${"tenantID"}}`, encodeURIComponent(String(tenantID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export namespaces to csv file.
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} [tenant] Namespace Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken: async (tenant?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember: async (tenant: string, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('removeNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('removeNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember: async (tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespacesApi - functional programming interface
 * @export
 */
export const NamespacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NamespacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, addNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespace(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespace(tenant, createNamespaceAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespace(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespace(tenant, createNamespaceAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespaceAdmin(tenantID, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export namespaces to csv file.
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} [tenant] Namespace Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceToken(tenant?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesAdmin(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeNamespaceMember(tenant, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NamespacesApi - factory interface
 * @export
 */
export const NamespacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NamespacesApiFp(configuration)
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespace(tenant, createNamespaceAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.editNamespace(tenant, createNamespaceAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: any): AxiosPromise<void> {
            return localVarFp.editNamespaceAdmin(tenantID, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Export namespaces to csv file.
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<any> {
            return localVarFp.exportNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} [tenant] Namespace Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken(tenant?: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getNamespaceToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespacesAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember(tenant: string, uid: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.removeNamespaceMember(tenant, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NamespacesApi - object-oriented interface
 * @export
 * @class NamespacesApi
 * @extends {BaseAPI}
 */
export class NamespacesApi extends BaseAPI {
    /**
     * Add a member to a namespace.
     * @summary Add a member to a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespace(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespace(tenant, createNamespaceAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public editNamespace(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespace(tenant, createNamespaceAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace admin
     * @param {string} tenantID Namespace\&#39;s tenant ID
     * @param {Namespace} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespaceAdmin(tenantID, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export namespaces to csv file.
     * @summary export namespace
     * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public exportNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).exportNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
     * @summary Get a new namespace\'s token
     * @param {string} [tenant] Namespace Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceToken(tenant?: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces list
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces admin
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespacesAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a member from a namespace.
     * @summary Remove a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).removeNamespaceMember(tenant, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a member role from a namespace.
     * @summary Update a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleAdmin(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleAdmin(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRuleAdmin(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRulesAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleAdmin(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRulesAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * Create a firewall rule.
     * @summary Create firewall rule Admin
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule admin
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteFirewallRuleAdmin(id: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule admin
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRuleAdmin(id: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules Admin
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRulesAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule admin
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateFirewallRuleAdmin(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordSession: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteRecordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecordSession: async (uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('enableRecordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordedSessionResponseInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus: async (uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatus', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin: async (uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatusAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordSession(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordSession(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableRecordSession(uid, recordedSessionResponseInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Delete a session record
         * @summary Delete a session record
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordSession(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRecordSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a session record
         * @summary Enable a session record
         * @param {string} uid 
         * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: any): AxiosPromise<void> {
            return localVarFp.enableRecordSession(uid, recordedSessionResponseInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSessionAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.getSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessions(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessionsAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Delete a session record
     * @summary Delete a session record
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public deleteRecordSession(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).deleteRecordSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a session record
     * @summary Enable a session record
     * @param {string} uid 
     * @param {Array<RecordedSessionResponseInner>} [recordedSessionResponseInner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public enableRecordSession(uid: string, recordedSessionResponseInner?: Array<RecordedSessionResponseInner>, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).enableRecordSession(uid, recordedSessionResponseInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSession(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session admin
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionAdmin(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status from if `session record` feature is enable.
     * @summary Get session record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionRecord(options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessions(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions admin
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionsAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status admin
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SshApi - axios parameter creator
 * @export
 */
export const SshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey: async (fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('addTagPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTagPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (publicKeyRequest?: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyAdmin: async (publicKeyRequest?: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deletePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysAdmin: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey: async (fingerprint: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('removeTagPublicKey', 'fingerprint', fingerprint)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('removeTagPublicKey', 'tag', tag)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags/{tag}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a SSH public key.
         * @summary Set SSH key
         * @param {SetSSHKeyRequest} [setSSHKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSSHKey: async (setSSHKeyRequest?: SetSSHKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSSHKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey: async (fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updatePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey: async (fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updateTagsPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SshApi - functional programming interface
 * @export
 */
export const SshApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SshApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKeyAdmin(publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeysAdmin(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagPublicKey(fingerprint, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set a SSH public key.
         * @summary Set SSH key
         * @param {SetSSHKeyRequest} [setSSHKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSSHKey(setSSHKeyRequest?: SetSSHKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetSSHKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSSHKey(setSSHKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicKey(fingerprint, updatePublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SshApi - factory interface
 * @export
 */
export const SshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SshApiFp(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.createPublicKey(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.createPublicKeyAdmin(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(fingerprint: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePublicKey(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<PublicKeyResponse>> {
            return localVarFp.getPublicKeys(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.getPublicKeysAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey(fingerprint: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeTagPublicKey(fingerprint, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a SSH public key.
         * @summary Set SSH key
         * @param {SetSSHKeyRequest} [setSSHKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSSHKey(setSSHKeyRequest?: SetSSHKeyRequest, options?: any): AxiosPromise<SetSSHKey200Response> {
            return localVarFp.setSSHKey(setSSHKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SshApi - object-oriented interface
 * @export
 * @class SshApi
 * @extends {BaseAPI}
 */
export class SshApi extends BaseAPI {
    /**
     * Add a tag to a public key.
     * @summary Add tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKey(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key admin
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKeyAdmin(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public key.
     * @summary Delete public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public deletePublicKey(fingerprint: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).deletePublicKey(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys
     * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeys(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys admin
     * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeysAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from public key.
     * @summary Remove tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).removeTagPublicKey(fingerprint, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a SSH public key.
     * @summary Set SSH key
     * @param {SetSSHKeyRequest} [setSSHKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public setSSHKey(setSSHKeyRequest?: SetSSHKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).setSSHKey(setSSHKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a public key.
     * @summary Update public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags in a public key.
     * @summary Update tags public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<GetStats200Response> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Get stats about the ShellHub instance.
     * @summary Get stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return StatsApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey: async (fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('addTagPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTagPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createDeviceTag', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tag', tag)
            const localVarPath = `/api/devices/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteTag', 'tag', tag)
            const localVarPath = `/api/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey: async (fingerprint: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('removeTagPublicKey', 'fingerprint', fingerprint)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('removeTagPublicKey', 'tag', tag)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags/{tag}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag: async (tag: string, renameTagRequest?: RenameTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('renameTag', 'tag', tag)
            const localVarPath = `/api/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey: async (fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updateTagsPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagPublicKey(fingerprint, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameTag(tag, renameTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsDevice(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey(fingerprint: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeTagPublicKey(fingerprint, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.renameTag(tag, renameTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Add a tag to a public key.
     * @summary Add tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from device.
     * @summary Delete a tag from device
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteDeviceTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag name.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from public key.
     * @summary Remove tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).removeTagPublicKey(fingerprint, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename a tag name.
     * @param {string} tag Tag\&#39;s name.
     * @param {RenameTagRequest} [renameTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).renameTag(tag, renameTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to device
     * @summary Update tags to device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags in a public key.
     * @summary Update tags public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin: async (userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (tenant?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTokenAdmin', 'id', id)
            const localVarPath = `/admin/api/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (login?: Login, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(login, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login_1: async (login?: Login, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(login, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserData: async (id: string, updateUserDataRequest?: UpdateUserDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserData', 'id', id)
            const localVarPath = `/api/users/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdmin(userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(tenant?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTokenAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(login?: Login, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login_1(login?: Login, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login_1(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserData(id, updateUserDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(id, updateUserPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin(userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUserAdmin(userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<any> {
            return localVarFp.exportUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.getSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(tenant?: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin(id: string, options?: any): AxiosPromise<GetUserTokenAdmin200Response> {
            return localVarFp.getUserTokenAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
         * @param {number} [page] Pagination page number
         * @param {number} [perPage] Pagination items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<UserAdminResponse>> {
            return localVarFp.getUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(login?: Login, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Get data about a user
         * @summary Login
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login_1(login?: Login, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login_1(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(id, userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserData(id, updateUserDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a User.
     * @summary Create a User admin
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserAdmin(userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export users to csv file.
     * @summary export users
     * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public exportUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).exportUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status from if `session record` feature is enable.
     * @summary Get session record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSessionRecord(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a token from its tenant.
     * @summary Get token
     * @param {string} [tenant] Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getToken(tenant?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user.
     * @summary Get user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user JWT token to login.
     * @summary Get user token
     * @param {string} id User\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserTokenAdmin(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserTokenAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of users.
     * @summary Get users
     * @param {string} [filter] Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;confirmed&#x60; where the value is &#x60;eq&#x60; to &#x60;true&#x60;.   This is a example to filter and get only the confirmed users. &#x60;&#x60;&#x60;json  [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: true       }   } ]  &#x60;&#x60;&#x60;    So, the output enconded string will result on:     &#x60;&#x60;&#x60;WwogICAgewogICAgInR5cGUiOiAicHJvcGVydHkiLAogICAgInBhcmFtcyI6IHsKICAgICAgICAibmFtZSI6ICJjb25maXJtZWQiLAogICAgICAgICJvcGVyYXRvciI6ICJlcSIsCiAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgIH0KXQ&#x3D;&#x3D;&#x60;&#x60;&#x60; 
     * @param {number} [page] Pagination page number
     * @param {number} [perPage] Pagination items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get data about a user
     * @summary Login
     * @param {Login} [login] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login(login?: Login, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).login(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get data about a user
     * @summary Login
     * @param {Login} [login] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login_1(login?: Login, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).login_1(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update user
     * @param {string} id 
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s data.
     * @summary Update user data
     * @param {string} id User\&#39;s ID.
     * @param {UpdateUserDataRequest} [updateUserDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserData(id, updateUserDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update only the user password.
     * @summary Update user password
     * @param {string} [id] User ID
     * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


